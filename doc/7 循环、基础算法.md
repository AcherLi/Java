# 数组元素逆序
  ![text](img/doc0701.png?raw=true)  
  * 定义两个索引变量start值为0，变量end值为数组长度减去1（即数组最后一个元素索引）  
  * 使用循环，完成数组索引start位置元素与end位置元素值互换。  
  * 在循环换过程中，每次互换结束后，start位置后移1，end位置前移1  
  在循环换过程中，最先判断start位置是否超越了end位置，若已超越，则跳出循环  
  ```java
  public static void receive(int[] arr){
    for (int start = 0, end = arr.length-1; start < end; start++,end--) {
      int temp = arr[start];
      arr[start] = arr[end];
      arr[end] = temp;
    }
  }
  ```
# 数组元素选择排序
  ![text](img/doc0702.png?raw=true)  
  * 使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）
  * 在每一圈中，通过for循环（内层循环）完成数组要比较的第一个元素与该元素后面的数组元素依次比较到数组的最后一个元素，把小的值放在第一个数组元素中
  * 在每一圈中，要参与比较的第一个元素由第几圈循环来决定。如上图所示
    + 进行第一圈元素比较时，要比较的第一个元素为数组第一个元素，即索引为0的元素
    + 进行第二圈元素比较时，要比较的第一个元素为数组第二个元素，即索引为1的元素
    + 依次类推，得出结论：进行第n圈元素比较时，要比较的第一个元素为数组第n个元素，即数组索引为n-1的元素  
  ```java
  //选择排序
  public static void selectSort(int[] arr) {
    //功能
    //外层循环用来控制数组循环的圈数
    for (int i = 0; i < arr.length-1; i++) {
      //内层循环用来完成元素值比较，把小的元素值互换到要比较的第一个元素中
      for (int j = i+1; j < arr.length; j++) {
        if (arr[i] > arr[j]) {
          int temp = arr[i];
          arr[i] = arr[j];
          arr[j] = temp;
        }
      }
    }
  }
  ```  
# 数组元素冒泡排序
  ![text](img/doc0703.png?raw=true)  
  * 使用for循环（外层循环），指定数组要循环的圈数（通过图解可知，数组循环的圈数为数组长度 - 1）
  * 在每一圈中，通过for循环（内层循环）完成相邻的元素值依次比较，把大的值放后面的元素中
  * 每圈内层循环的次数，由第几圈循环来决定。如上图所示
    + 进行第一圈元素比较时，内层循环次数为数组长度 - 1
    + 进行第二圈元素比较时，内层循环次数为数组长度 - 2
    + 依次类推，得出结论：进行第n圈元素比较时，内层循环次数为数组长度 - n
  ```java
  //冒泡排序
  public static void bubbleSort(int[] arr) {
    //功能
    //外层循环用来控制数组循环的圈数
    for (int i = 0; i < arr.length-1; i++) {
      //j < arr.length-1 为了避免角标越界
      //j < arr.length-1-i 为了比较效率,避免重复比较
      //内层循环用来完成元素值比较，把大的元素值互换到后面
      for (int j = 0; j < arr.length-1-i; j++) {
        if (arr[j] > arr[j+1]) {
          int temp = arr[j];
          arr[j] = arr[j+1];
          arr[j+1] = temp;
        }
      }
    }
  }
  ```  
## 数组元素普通查找
  ![text](img/doc0704.png?raw=true)  
  * 使用for循环，遍历数组，得到每个数组元素值
  * 在每次循环中，使用if条件语句进行当前数组元素值与要查找的数值进行对比，若比较结果相等，直接返回当前数组元素的索引值
  * 若整个循环结束后，比对结果数值没有相等的情况，说明该数组中没有存储要查找的数值，此时，返回一个索引值-1
  ```java
  //普通查找
  public static int getArrayIndex(int[] arr, int number) {
    //把数组中的元素依次与指定的数值 进行比较
    for (int i = 0; i < arr.length; i++) {
      if (arr[i] == number) {
        //找到了
        return i;
      }
    }
    return -1;
  }
  ```  
## 数组元素二分查找（折半查找）
  ![text](img/doc0705.png?raw=true)  
  * 定义3个用来记录索引值的变量，变量min记录当前范围最小索引值，初始值为0；变量max记录当前范围最大索引值，初始值为数组长度-1；变量mid记录当前当前范围最中间元素的索引值，初始值为(min+max) / 2
  * 使用循环，判断当前范围下，最中间元素值与指定查找的数值是否相等
    + 若相等，结束循环，返回当前范围最中间元素的索引值mid
    + 若不相等，根据比较结果，缩小查询范围为上一次查询范围的一般
      - 中间元素值 比 要查询的数值大，说明要查询的数值在当前范围的最小索引位置与中间索引位置之间，此时，更新查询范围为: 范围最大索引值 = 上一次中间索引位置 -1；
      - 中间元素值 比 要查询的数值小，说明要查询的数值在当前范围的最大索引位置与中间索引位置之间，此时，更新查询范围为: 范围最小索引值 = 上一次中间索引位置 +1；
      - 在新的查询范围中，更新中间元素值的位置，再次使用最中间元素值与指定查找的数值是否相等。 中间索引值 = (范围最小索引值 +范围最大索引值) / 2;
  * 每次查询范围缩小一半后，使用if语句判断，查询范围是否小于0个元素，若小于0个元素，则说明指定数值没有查询到，返回索引值-1。
  ```java
  //二分查找法(折半查找法)
  public static int halfSearch(int[] arr, int number) {
    //定义3个变量，用来记录min, min, mid的位置
    int min = 0;
    int max = arr.length-1;
    int mid = 0;
    while (min <= max) {
      mid = (min+max)/2;
      //没找到， 更新范围，继续比较
      //更新范围
      if (arr[mid] > number) {
        //在左边
        max = mid-1;
      } else if(arr[mid] < number){
        //在右边
        min = mid+1;
      } else{
        return mid ;
      }
    }
    return -1;
  }
  ```  

